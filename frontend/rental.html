<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å ´åœ°ç§Ÿç”¨é ç´„ | Studio Booking</title>
    <style>
        :root {
            --brand-primary: #0b4f6c;
            --brand-secondary: #145da0;
            --surface: #f8f9fb;
            --surface-alt: #ffffff;
            --accent: #f2c94c;
            --danger: #f2545b;
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Microsoft JhengHei', 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: #EDEDE9;
            color: #1f2933;
        }

        a {
            color: inherit;
            text-decoration: none;
        }

        header {
            background: linear-gradient(135deg, var(--brand-secondary) 0%, var(--brand-primary) 100%);
            color: #fff;
            padding: 40px 24px 60px;
        }

        .nav-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 16px;
            margin-bottom: 40px;
        }

        .nav-bar a {
            color: #fff;
            font-weight: 600;
            letter-spacing: 0.04em;
        }

        .hero {
            max-width: 960px;
            margin: 0 auto;
            text-align: center;
        }

        .hero h1 {
            font-size: 2.4rem;
            margin-bottom: 12px;
        }

        .hero p {
            opacity: 0.9;
        }

        main {
            max-width: 1100px;
            margin: -40px auto 80px;
            padding: 0 24px;
        }

        .card {
            background: rgba(255, 255, 255, 0.98);
            border-radius: 24px;
            box-shadow: 0 28px 50px rgba(15, 30, 84, 0.1);
            padding: 32px;
            margin-bottom: 32px;
        }

        .card h2 {
            font-size: 1.6rem;
            color: var(--brand-secondary);
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 20px;
        }

        .grid {
            display: grid;
            gap: 24px;
        }

        @media (min-width: 960px) {
            .grid.two {
                grid-template-columns: 7fr 5fr;
            }
        }

        label {
            font-weight: 600;
            color: #334155;
            display: block;
            margin-bottom: 8px;
        }

        input,
        textarea {
            width: 100%;
            border: 2px solid #d6dde6;
            border-radius: 12px;
            padding: 12px 14px;
            font-size: 1rem;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        input:focus,
        textarea:focus {
            outline: none;
            border-color: var(--brand-secondary);
            box-shadow: 0 0 0 4px rgba(20, 93, 160, 0.16);
        }

        .slot-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(90px, 1fr));
            gap: 10px;
        }

        .slot-button {
            border: 2px solid #e2e7ef;
            border-radius: 12px;
            padding: 10px 6px;
            text-align: center;
            background: #fff;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .slot-button:hover:not(.disabled) {
            border-color: var(--brand-secondary);
            transform: translateY(-2px);
            box-shadow: 0 10px 16px rgba(20, 93, 160, 0.08);
        }

        .slot-button.selected {
            background: linear-gradient(135deg, var(--brand-secondary) 0%, var(--brand-primary) 100%);
            color: #fff;
            border-color: var(--brand-primary);
        }

        .slot-button.disabled {
            background: #f0f0f0;
            color: #94a3b8;
            cursor: not-allowed;
            text-decoration: line-through;
        }

        .slot-button.pending {
            background: #fff8e1;
            border-color: #f2c94c;
            color: #8f6a02;
            cursor: not-allowed;
        }

        .legend {
            display: flex;
            gap: 16px;
            flex-wrap: wrap;
            margin-top: 16px;
            font-size: 0.92rem;
            color: #475569;
        }

        .legend span {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .legend-box {
            width: 16px;
            height: 16px;
            border-radius: 4px;
            border: 1px solid #d6dde6;
        }

        .legend-box.available {
            background: #fff;
        }

        .legend-box.pending {
            background: #fff8e1;
            border-color: #f2c94c;
        }

        .legend-box.unavailable {
            background: #f0f0f0;
        }

        .summary-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .summary-item {
            border: 1px solid #dbe2ed;
            border-radius: 14px;
            padding: 14px 16px;
            background: #fff;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 12px;
        }

        .summary-date {
            font-weight: 700;
            color: var(--brand-secondary);
            margin-top: 4px;
        }

        .summary-item strong {
            color: var(--brand-primary);
        }

        .summary-item button {
            border: none;
            background: var(--danger);
            color: #fff;
            padding: 6px 12px;
            border-radius: 999px;
            cursor: pointer;
        }

        .summary-totals {
            margin-top: 18px;
            border-top: 1px solid #e2e8f0;
            padding-top: 18px;
            display: flex;
            flex-direction: column;
            gap: 6px;
            color: #1e293b;
        }

        .totals-row {
            display: flex;
            justify-content: space-between;
        }

        .totals-row.total {
            font-weight: 700;
            font-size: 1.1rem;
            color: var(--brand-primary);
        }

        .btn-primary {
            width: 100%;
            background: linear-gradient(135deg, var(--brand-secondary) 0%, var(--brand-primary) 100%);
            color: #fff;
            font-weight: 600;
            border: none;
            border-radius: 16px;
            padding: 16px 20px;
            font-size: 1rem;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .btn-primary:disabled {
            background: #cbd5e1;
            cursor: not-allowed;
            box-shadow: none;
        }

        .btn-primary:not(:disabled):hover {
            transform: translateY(-2px);
            box-shadow: 0 18px 30px rgba(15, 55, 98, 0.2);
        }

        .status-message {
            padding: 14px 18px;
            border-radius: 12px;
            font-weight: 600;
            margin-bottom: 18px;
            display: none;
        }

        .status-message.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status-message.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .instruction-list {
            background: #fff7e6;
            border-radius: 18px;
            padding: 20px 24px;
            border: 1px solid #f2c94c;
        }

        .instruction-list h3 {
            margin-top: 0;
            margin-bottom: 12px;
            color: #8f6a02;
        }

        .instruction-list ol {
            margin: 0 0 0 20px;
            line-height: 1.6;
        }

        .payment-panel {
            background: var(--surface);
            border-radius: 16px;
            border: 1px solid #dbe2ed;
            padding: 20px;
        }

        .payment-reminder-modal {
            position: fixed;
            inset: 0;
            background: rgba(15, 23, 42, 0.45);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 16px;
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease;
        }

        .payment-reminder-modal.active {
            opacity: 1;
            pointer-events: auto;
        }

        .payment-reminder-content {
            background: #fff;
            width: min(480px, 100%);
            border-radius: 18px;
            padding: 24px 24px 20px;
            box-shadow: 0 24px 50px rgba(15, 23, 42, 0.2);
            position: relative;
        }

        .payment-reminder-close {
            position: absolute;
            top: 12px;
            right: 12px;
            border: none;
            background: #e2e8f0;
            color: #0f172a;
            border-radius: 50%;
            width: 32px;
            height: 32px;
            font-weight: 700;
            cursor: pointer;
        }

        .payment-reminder-content h3 {
            margin-top: 0;
            color: var(--brand-secondary);
            margin-bottom: 10px;
        }

        .payment-reminder-content p {
            color: #1f2937;
            line-height: 1.6;
            margin: 0 0 16px;
        }

        .whatsapp-button {
            display: inline-flex;
            align-items: center;
            gap: 10px;
            padding: 12px 16px;
            background: #25d366;
            color: #fff;
            border: none;
            border-radius: 12px;
            font-weight: 700;
            cursor: pointer;
            text-decoration: none;
            box-shadow: 0 12px 24px rgba(37, 211, 102, 0.25);
        }

        .whatsapp-button[aria-disabled="true"] {
            background: #cbd5e1;
            cursor: not-allowed;
            box-shadow: none;
        }

        /* Skeleton Loading */
        .skeleton {
            background: #f0f0f0;
            background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
            background-size: 200% 100%;
            animation: shimmer 1.5s infinite;
            border-radius: 8px;
        }

        @keyframes shimmer {
            0% {
                background-position: 200% 0;
            }

            100% {
                background-position: -200% 0;
            }
        }

        .skeleton-slot {
            height: 40px;
            width: 100%;
            border-radius: 12px;
        }
    </style>
</head>

<body>
    <header>
        <div class="nav-bar">
            <a href="./index.html">â† è¿”å›é¦–é </a>
            <a href="./classes.html">èª²å ‚é«”é©—å€</a>
        </div>
        <div class="hero">
            <h1>å ´åœ°ç§Ÿç”¨é ç´„</h1>
            <p id="hero-subtitle">é¸æ“‡æ—¥æœŸèˆ‡æ™‚æ®µï¼Œç«‹å³é ç´„æ•´å€‹å ´åœ°ã€‚</p>
        </div>
    </header>
    <main>
        <div class="card instruction-list" id="instruction-card" style="display:none;"></div>
        <div class="grid two">
            <div class="card">
                <h2>ğŸ“… é¸æ“‡æ—¥æœŸèˆ‡æ™‚æ®µ</h2>
                <div class="form-group">
                    <label for="room-select">é¸æ“‡ç©ºé–“ (å¦‚æœ‰æŒ‡å®š)</label>
                    <select id="room-select" disabled>
                        <option value="">æ­£åœ¨è¼‰å…¥...</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="date-input">é ç´„æ—¥æœŸ</label>
                    <input type="date" id="date-input" min="" max="">
                </div>
                <div id="slots-section" style="display:none;">
                    <div class="slot-grid" id="slot-grid"></div>
                    <div class="legend">
                        <span><span class="legend-box available"></span> å¯é¸</span>
                        <span><span class="legend-box pending"></span> å¾…ç¢ºèª</span>
                        <span><span class="legend-box unavailable"></span> å·²é ç´„</span>
                    </div>
                </div>
            </div>
            <div class="card">
                <h2>ğŸ›’ å·²é¸æ“‡çš„æ™‚æ®µ</h2>
                <div id="status-success" class="status-message success"></div>
                <div id="status-error" class="status-message error"></div>
                <div id="summary-list" class="summary-list"></div>
                <div class="summary-totals">
                    <div class="totals-row"><span>å·²é¸æ™‚æ®µ</span><span id="total-blocks">0</span></div>
                    <div class="totals-row"><span>ç¸½æ™‚æ•¸</span><span id="total-hours">0 å°æ™‚</span></div>
                    <div class="totals-row"><span>ç¸½äººæ•¸</span><span id="total-people">0</span></div>
                    <div class="totals-row total"><span>é ä¼°é‡‘é¡</span><span>HK$ <span id="total-amount">0</span></span>
                    </div>
                </div>
            </div>
        </div>
        <div class="card" id="contact-card" style="display:none;">
            <h2>ğŸ‘¤ è¯çµ¡è³‡æ–™</h2>
            <form id="booking-form">
                <div class="grid" style="gap:18px;">
                    <div>
                        <label for="customerName">å§“å *</label>
                        <input type="text" id="customerName" required>
                    </div>
                    <div>
                        <label for="email">é›»å­éƒµä»¶ *</label>
                        <input type="email" id="email" required>
                    </div>
                    <div>
                        <label for="phone">é›»è©± / WhatsApp *</label>
                        <input type="tel" id="phone" required>
                    </div>
                </div>
                <div class="form-group" style="margin-top:18px;">
                    <label for="people-count">åƒèˆ‡äººæ•¸ (å¯é¸ï¼Œæœ€å¤š 18 äºº)</label>
                    <input type="number" id="people-count" min="1" max="18" placeholder="ä¾‹å¦‚ 6">
                </div>
                <div class="form-group" style="margin-top:18px;">
                    <label for="notes">å‚™è¨» (å¯é¸)</label>
                    <textarea id="notes" rows="3" placeholder="å‘Šè¨´æˆ‘å€‘æ‚¨çš„ç‰¹åˆ¥éœ€æ±‚..."></textarea>
                </div>
                <div class="payment-panel" id="payment-info"></div>
                <button type="submit" class="btn-primary" id="submit-btn" disabled>æäº¤é ç´„ç”³è«‹</button>
            </form>
        </div>
    </main>
    <div class="payment-reminder-modal" id="payment-reminder-modal" aria-hidden="true">
        <div class="payment-reminder-content">
            <button type="button" class="payment-reminder-close" id="payment-reminder-close" <a
                id="payment-reminder-whatsapp" class="whatsapp-button" href="#" target="_blank" rel="noopener">æ‰“é–‹
                WhatsApp</a>
        </div>
    </div>
    <script>
        const API_BASE_URL = '/api';

        const state = {
            settings: null,
            selectedDate: '',
            availabilityByDate: new Map(),
            selectedSlotsByDate: new Map(),
            selectedRanges: [],
            slotInterval: 30,
            activeRoomId: null, // Track selected room
            rooms: [] // Store fetched rooms
        };

        async function fetchRentalItems() {
            try {
                const res = await fetch(`${API_BASE_URL}/items`); // Returns { workshops, roomRentals }
                const data = await res.json();
                return data.roomRentals || [];
            } catch (e) {
                console.error(e);
                return [];
            }
        }

        function populateRoomSelect(rooms) {
            state.rooms = rooms;
            const select = document.getElementById('room-select');
            select.innerHTML = '<option value="">æ‰€æœ‰ç©ºé–“ (è‡ªå‹•åˆ†é…)</option>';

            rooms.forEach(room => {
                const opt = document.createElement('option');
                opt.value = room.id;
                opt.textContent = `${room.name} (å®¹ç´ ${room.capacity}äºº)`;
                select.appendChild(opt);
            });

            select.disabled = false;

            select.addEventListener('change', (e) => {
                state.activeRoomId = e.target.value || null;
                // Refetch availability if date is selected
                if (state.selectedDate) {
                    fetchAvailability(state.selectedDate);
                }
            });
        }

        const elements = {
            dateInput: document.getElementById('date-input'),
            roomSelect: document.getElementById('room-select'),
            peopleInput: document.getElementById('people-count'),
            slotGrid: document.getElementById('slot-grid'),
            slotsSection: document.getElementById('slots-section'),
            summaryList: document.getElementById('summary-list'),
            totalBlocks: document.getElementById('total-blocks'),
            totalHours: document.getElementById('total-hours'),
            totalPeople: document.getElementById('total-people'),
            totalAmount: document.getElementById('total-amount'),
            successMessage: document.getElementById('status-success'),
            errorMessage: document.getElementById('status-error'),
            submitButton: document.getElementById('submit-btn'),
            contactCard: document.getElementById('contact-card'),
            instructionCard: document.getElementById('instruction-card'),
            paymentInfo: document.getElementById('payment-info'),
            customerName: document.getElementById('customerName'),
            email: document.getElementById('email'),
            phone: document.getElementById('phone'),
            notes: document.getElementById('notes'),
            heroSubtitle: document.getElementById('hero-subtitle'),
            paymentReminderModal: document.getElementById('payment-reminder-modal'),
            paymentReminderWhatsapp: document.getElementById('payment-reminder-whatsapp'),
            paymentReminderClose: document.getElementById('payment-reminder-close')
        };

        function loadUserDetails() {
            try {
                const saved = localStorage.getItem('bookingUserDetails');
                if (saved) {
                    const details = JSON.parse(saved);
                    if (details.name) elements.customerName.value = details.name;
                    if (details.email) elements.email.value = details.email;
                    if (details.phone) elements.phone.value = details.phone;
                }
            } catch (e) { console.warn('Failed to load user details', e); }
        }

        function saveUserDetails() {
            try {
                const details = {
                    name: elements.customerName.value,
                    email: elements.email.value,
                    phone: elements.phone.value
                };
                localStorage.setItem('bookingUserDetails', JSON.stringify(details));
            } catch (e) { console.warn('Failed to save user details', e); }
        }

        function renderSkeletonSlots() {
            elements.slotGrid.innerHTML = '';
            for (let i = 0; i < 18; i++) {
                const div = document.createElement('div');
                div.className = 'skeleton skeleton-slot';
                elements.slotGrid.appendChild(div);
            }
            elements.slotsSection.style.display = 'block';
        }

        function formatDateInputValue(date) {
            if (!(date instanceof Date) || Number.isNaN(date.getTime())) {
                return '';
            }
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        function timeToMinutes(value) {
            const [h, m] = value.split(':').map(Number);
            return (h * 60) + m;
        }

        function minutesToTime(minutes) {
            const hour = Math.floor(minutes / 60);
            const minute = minutes % 60;
            return `${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;
        }

        function generateSlots(startTime, endTime, intervalMinutes) {
            const slots = [];
            let cursor = timeToMinutes(startTime);
            const end = timeToMinutes(endTime);
            while (cursor < end) {
                slots.push(minutesToTime(cursor));
                cursor += intervalMinutes;
            }
            return slots;
        }

        function ensureSelectionSet(date) {
            if (!date) {
                return null;
            }
            let set = state.selectedSlotsByDate.get(date);
            if (!set) {
                set = new Set();
                state.selectedSlotsByDate.set(date, set);
            }
            return set;
        }

        function cleanupEmptySelections() {
            Array.from(state.selectedSlotsByDate.entries()).forEach(([date, slots]) => {
                if (!slots || slots.size === 0) {
                    state.selectedSlotsByDate.delete(date);
                }
            });
        }

        function groupSlotsForDate(date) {
            const slots = state.selectedSlotsByDate.get(date);
            if (!slots || slots.size === 0) {
                return [];
            }
            const sorted = Array.from(slots)
                .sort((a, b) => timeToMinutes(a) - timeToMinutes(b));
            const groups = [];
            let current = [];
            const interval = state.slotInterval;
            sorted.forEach((slot) => {
                if (current.length === 0) {
                    current.push(slot);
                    return;
                }
                const prev = current[current.length - 1];
                if (timeToMinutes(slot) - timeToMinutes(prev) === interval) {
                    current.push(slot);
                } else {
                    groups.push(current);
                    current = [slot];
                }
            });
            if (current.length > 0) {
                groups.push(current);
            }
            return groups.map(group => ({
                start: group[0],
                end: minutesToTime(timeToMinutes(group[group.length - 1]) + interval),
                slots: group
            }));
        }

        function getAllSelectedGroups() {
            cleanupEmptySelections();
            const dates = Array.from(state.selectedSlotsByDate.keys()).sort();
            const aggregated = [];
            dates.forEach(date => {
                const groups = groupSlotsForDate(date);
                groups.forEach(group => {
                    aggregated.push({ date, ...group });
                });
            });
            state.selectedRanges = aggregated;
            return aggregated;
        }

        function resolvePeakSchedule(settings) {
            const schedule = settings?.pricing?.peakSchedule;
            if (!schedule) return null;
            const days = Array.isArray(schedule.days)
                ? schedule.days.map(day => day.toString().toLowerCase())
                : [];
            return {
                days,
                startTime: schedule.startTime || '18:00',
                endTime: schedule.endTime || '23:00'
            };
        }

        function determinePeriodType(date, startTime, endTime, settings) {
            const schedule = resolvePeakSchedule(settings);
            if (!schedule || schedule.days.length === 0) return 'normal';
            const parsed = new Date(`${date}T00:00:00`);
            if (Number.isNaN(parsed.getTime())) return 'normal';
            const dayToken = ['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat'][parsed.getDay()];
            if (!schedule.days.includes(dayToken)) return 'normal';
            const startMinutes = timeToMinutes(startTime);
            const endMinutes = timeToMinutes(endTime);
            const peakStart = timeToMinutes(schedule.startTime);
            const peakEnd = timeToMinutes(schedule.endTime);
            const overlaps = startMinutes < peakEnd && endMinutes > peakStart;
            return overlaps ? 'peak' : 'normal';
        }

        function resolveHourlyRate(pricing, peopleCount, periodType) {
            const rateTable = pricing || {};
            const cap = Number(peopleCount);
            if (cap > 18) {
                throw new Error('æœ€å¤š 18 äºº');
            }
            const baseKey = periodType === 'peak' ? 'peak' : 'normal';
            if (cap <= 10) {
                return Number(rateTable[`${baseKey}UpTo10`] || 0);
            }
            return Number(rateTable[`${baseKey}UpTo18`] || 0);
        }

        function resolvePeopleCountInput() {
            const value = Number(elements.peopleInput.value);
            if (!Number.isFinite(value) || value <= 0) {
                return null;
            }
            return Math.min(Math.floor(value), 18);
        }

        function calculateTotals() {
            const groups = getAllSelectedGroups();
            const providedPeopleCount = resolvePeopleCountInput();
            const effectivePeopleCount = providedPeopleCount ?? 1;
            let totalMinutes = 0;
            let totalPrice = 0;

            groups.forEach(group => {
                const duration = timeToMinutes(group.end) - timeToMinutes(group.start);
                totalMinutes += duration;
                if (state.settings?.pricing) {
                    try {
                        const periodType = determinePeriodType(group.date, group.start, group.end, state.settings);
                        const rate = resolveHourlyRate(state.settings.pricing, effectivePeopleCount, periodType);
                        totalPrice += rate * (duration / 60);
                    } catch (error) {
                        console.error('Failed to resolve pricing for group:', error);
                    }
                }
            });

            elements.totalBlocks.textContent = groups.length.toString();
            elements.totalHours.textContent = `${(totalMinutes / 60).toFixed(1)} å°æ™‚`;
            elements.totalPeople.textContent = providedPeopleCount ? providedPeopleCount.toString() : 'â€”';
            elements.totalAmount.textContent = totalPrice.toFixed(2);
            elements.submitButton.disabled = groups.length === 0;
            elements.contactCard.style.display = groups.length > 0 ? 'block' : 'none';
        }

        function renderSummary() {
            const groups = getAllSelectedGroups();
            elements.summaryList.innerHTML = '';

            if (groups.length === 0) {
                const empty = document.createElement('div');
                empty.textContent = 'å°šæœªé¸æ“‡ä»»ä½•æ™‚æ®µã€‚';
                empty.style.color = '#64748b';
                elements.summaryList.appendChild(empty);
                calculateTotals();
                return;
            }

            const groupedByDate = new Map();
            groups.forEach(group => {
                if (!groupedByDate.has(group.date)) {
                    groupedByDate.set(group.date, []);
                }
                groupedByDate.get(group.date).push(group);
            });

            Array.from(groupedByDate.entries()).forEach(([date, items]) => {
                const header = document.createElement('div');
                header.className = 'summary-date';
                header.textContent = date;
                elements.summaryList.appendChild(header);

                items.forEach(group => {
                    const row = document.createElement('div');
                    row.className = 'summary-item';
                    const info = document.createElement('div');
                    info.innerHTML = `<div>${group.start} - ${group.end}</div>`;
                    const removeBtn = document.createElement('button');
                    removeBtn.type = 'button';
                    removeBtn.textContent = 'ç§»é™¤';
                    removeBtn.addEventListener('click', () => {
                        const selection = state.selectedSlotsByDate.get(date);
                        if (selection) {
                            group.slots.forEach(slot => selection.delete(slot));
                            if (selection.size === 0) {
                                state.selectedSlotsByDate.delete(date);
                            }
                        }
                        if (state.selectedDate === date) {
                            renderSlots();
                        }
                        renderSummary();
                    });
                    row.appendChild(info);
                    row.appendChild(removeBtn);
                    elements.summaryList.appendChild(row);
                });
            });

            calculateTotals();
        }

        function toggleSlotSelection(slot) {
            const { time, status } = slot;
            if (status !== 'available') return;

            const date = state.selectedDate;
            if (!date) return;

            const selectedSet = state.selectedSlotsByDate.get(date) || new Set();
            if (!state.selectedSlotsByDate.has(date)) {
                state.selectedSlotsByDate.set(date, selectedSet);
            }

            if (selectedSet.has(time)) {
                selectedSet.delete(time);
            } else {
                selectedSet.add(time);
            }

            renderSlots();
            renderSummary();
        }

        function renderSlots() {
            const date = state.selectedDate;
            if (!date) {
                elements.slotGrid.innerHTML = '';
                elements.slotsSection.style.display = 'none';
                return;
            }

            const availability = state.availabilityByDate.get(date);
            if (!availability) {
                return;
            }

            const { openingHours, confirmedSlots = [], pendingSlots = [] } = availability;
            const interval = state.slotInterval;
            const generatedSlots = generateSlots(openingHours.startTime, openingHours.endTime, interval);
            const currentSelected = state.selectedSlotsByDate.get(date) || new Set();
            const isSelected = (time) => currentSelected.has(time);

            // Map generated slots to objects with status
            const slots = generatedSlots.map(time => {
                if (confirmedSlots.includes(time)) {
                    return { time, status: 'booked' };
                } else if (pendingSlots.includes(time)) {
                    return { time, status: 'pending' };
                } else {
                    return { time, status: 'available' };
                }
            });

            elements.slotGrid.innerHTML = '';
            slots.forEach(slot => {
                const button = document.createElement('div');
                button.className = 'slot-button';
                button.textContent = slot.time;

                let tooltip = '';

                if (slot.status === 'booked' || slot.status === 'unavailable') {
                    button.classList.add('disabled');
                    button.classList.add('unavailable'); // For legend reference if needed
                    tooltip = 'æ­¤æ™‚æ®µå·²è¢«é ç´„æˆ–ä¸é–‹æ”¾';
                } else if (slot.status === 'pending') {
                    button.classList.add('pending');
                    tooltip = 'æ­¤æ™‚æ®µæ­£åœ¨ç­‰å¾…ç¢ºèª';
                } else {
                    button.classList.add('available');
                    tooltip = 'å¯é ç´„';
                    button.addEventListener('click', () => toggleSlotSelection(slot));
                }

                if (isSelected(slot.time)) {
                    button.classList.add('selected');
                }

                if (tooltip) {
                    button.title = tooltip;
                    button.setAttribute('aria-label', `${slot.time} ${tooltip}`);
                }

                elements.slotGrid.appendChild(button);
            });
        }

        async function fetchAvailability(date) {
            if (!date) return;
            state.selectedDate = date;
            state.availabilityByDate.delete(date); // Clear previous availability for this date

            // Show skeletons
            renderSkeletonSlots();

            try {
                let url = `${API_BASE_URL}/rentals/availability?date=${date}`;
                if (state.activeRoomId) {
                    url += `&itemId=${state.activeRoomId}`;
                }
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error('Failed to load availability');
                }
                const availability = await response.json();
                state.availabilityByDate.set(date, availability);
            } catch (error) {
                console.error('Unable to load availability:', error);
                state.availabilityByDate.delete(date);
            } finally {
                renderSlots(date);
            }
        }

        function applyInstructions(settings) {
            const instructions = settings?.bookingInstructions;
            if (!instructions) return;
            const zhTitle = instructions.titleZh || 'é‡è¦é ç´„é ˆçŸ¥';
            const items = Object.keys(instructions)
                .filter(key => /^instruction\d+Zh$/.test(key))
                .sort((a, b) => a.localeCompare(b))
                .map(key => instructions[key])
                .filter(Boolean);
            if (items.length === 0) return;
            const card = elements.instructionCard;
            card.innerHTML = `<h3>${zhTitle}</h3><ol>${items.map(item => `<li>${item}</li>`).join('')}</ol>`;
            card.style.display = 'block';
        }

        function renderPaymentInfo(settings) {
            const payments = settings?.paymentMethods || {};
            const parts = [];
            if (payments.bankTransfer?.enabled) {
                parts.push(`éŠ€è¡Œè½‰å¸³ï¼š${payments.bankTransfer.bankName} ${payments.bankTransfer.accountNumber} (${payments.bankTransfer.accountName})`);
            }
            if (payments.payme?.enabled) {
                const name = payments.payme.displayName || 'PayMe';
                const phone = payments.payme.phoneNumber || '';
                parts.push(`PayMeï¼š${`${name} ${phone}`.trim()}`);
            }
            if (payments.fps?.enabled) {
                const label = payments.fps.displayName || 'FPS è½‰æ•¸å¿«';
                const number = payments.fps.fpsNumber || '';
                parts.push(`${label}ï¼š${number}`.trim());
            }
            if (parts.length === 0) {
                elements.paymentInfo.textContent = 'è«‹ä¾ç…§å·¥ä½œäººå“¡æŒ‡ç¤ºå®Œæˆä»˜æ¬¾ã€‚';
            } else {
                elements.paymentInfo.innerHTML = parts.map(text => `<div>â€¢ ${text}</div>`).join('');
            }
        }

        function getWhatsappNumber() {
            return (state.settings?.contactInfo?.whatsapp || '').toString().replace(/\D/g, '');
        }

        function buildWhatsappLink(bookingId = '') {
            const number = getWhatsappNumber();
            if (!number) return null;
            const message = bookingId ? `ä½ å¥½ï¼Œæˆ‘å‰›æäº¤äº†é ç´„ (${bookingId})ï¼Œé€™æ˜¯æˆ‘çš„ä»˜æ¬¾è­‰æ˜ã€‚` : 'ä»˜æ¬¾è­‰æ˜';
            return `https://wa.me/${number}?text=${encodeURIComponent(message)}`;
        }

        function openPaymentReminderModal(bookingId = '') {
            if (!elements.paymentReminderModal) return;
            const link = buildWhatsappLink(bookingId);
            if (link) {
                elements.paymentReminderWhatsapp.href = link;
                elements.paymentReminderWhatsapp.setAttribute('aria-disabled', 'false');
            } else {
                elements.paymentReminderWhatsapp.href = '#';
                elements.paymentReminderWhatsapp.setAttribute('aria-disabled', 'true');
            }
            elements.paymentReminderModal.classList.add('active');
            elements.paymentReminderModal.setAttribute('aria-hidden', 'false');
        }

        function closePaymentReminderModal() {
            if (!elements.paymentReminderModal) return;
            elements.paymentReminderModal.classList.remove('active');
            elements.paymentReminderModal.setAttribute('aria-hidden', 'true');
        }

        function saveUserDetails() {
            try {
                const userDetails = {
                    customerName: elements.customerName.value,
                    email: elements.email.value,
                    phone: elements.phone.value
                };
                localStorage.setItem('bookingUserDetails', JSON.stringify(userDetails));
            } catch (e) {
                console.error('Failed to save user details to localStorage', e);
            }
        }

        function loadUserDetails() {
            try {
                const savedDetails = localStorage.getItem('bookingUserDetails');
                if (savedDetails) {
                    const userDetails = JSON.parse(savedDetails);
                    elements.customerName.value = userDetails.customerName || '';
                    elements.email.value = userDetails.email || '';
                    elements.phone.value = userDetails.phone || '';
                }
            } catch (e) {
                console.error('Failed to load user details from localStorage', e);
            }
        }

        function updateSubmitButtonState() {
            elements.submitButton.disabled = getAllSelectedGroups().length === 0;
        }

        async function loadSettings() {
            const response = await fetch(`${API_BASE_URL}/settings`);
            if (!response.ok) {
                throw new Error('Failed to load settings');
            }
            const settings = await response.json();
            state.settings = settings;
            state.slotInterval = Number(settings.bookingRules?.slotInterval || 30);
            applyInstructions(settings);
            renderPaymentInfo(settings);
            if (settings.operatingHours?.daysLabelZh) {
                elements.heroSubtitle.textContent = `${settings.operatingHours.daysLabelZh} Â· ${settings.operatingHours.startTime || '07:00'} - ${settings.operatingHours.endTime || '22:00'}`;
            }
            const rules = settings.bookingRules || {};
            const minDays = Number(rules.minAdvanceBooking || 0);
            const maxDays = Number(rules.maxAdvanceBooking || 30);
            const today = new Date();
            today.setDate(today.getDate() + minDays);
            const maxDate = new Date();
            maxDate.setDate(maxDate.getDate() + maxDays);
            elements.dateInput.min = formatDateInputValue(today);
            elements.dateInput.max = formatDateInputValue(maxDate);
        }

        function setTodayAsMinDate() {
            const today = new Date();
            elements.dateInput.min = formatDateInputValue(today);
        }

        async function handleDateChange(event) {
            const value = event.target.value;
            state.selectedDate = value;
            if (value) {
                elements.slotsSection.style.display = 'block';
                renderSkeletonSlots(); // Show skeleton immediately
                await fetchAvailability(value); // Await fetchAvailability
            } else {
                elements.slotsSection.style.display = 'none';
                elements.slotGrid.innerHTML = '';
            }
            renderSummary();
        }

        elements.dateInput.addEventListener('change', handleDateChange);

        elements.peopleInput.addEventListener('input', () => {
            const parsed = resolvePeopleCountInput();
            if (parsed !== null && parsed.toString() !== elements.peopleInput.value) {
                elements.peopleInput.value = parsed.toString();
            }
            if (parsed === null && elements.peopleInput.value) {
                elements.peopleInput.value = '';
            }
            calculateTotals();
        });

        elements.paymentReminderClose?.addEventListener('click', closePaymentReminderModal);
        elements.paymentReminderModal?.addEventListener('click', (event) => {
            if (event.target === elements.paymentReminderModal) {
                closePaymentReminderModal();
            }
        });
        elements.paymentReminderWhatsapp?.addEventListener('click', (event) => {
            if (elements.paymentReminderWhatsapp.getAttribute('aria-disabled') === 'true') {
                event.preventDefault();
            }
        });

        document.getElementById('booking-form').addEventListener('submit', async (event) => {
            event.preventDefault();
            elements.successMessage.style.display = 'none';
            elements.errorMessage.style.display = 'none';

            const groups = getAllSelectedGroups();
            if (groups.length === 0) {
                elements.errorMessage.textContent = 'è«‹å…ˆé¸æ“‡é ç´„æ™‚æ®µã€‚';
                elements.errorMessage.style.display = 'block';
                return;
            }

            const payload = {
                customerName: elements.customerName.value.trim(),
                email: elements.email.value.trim(),
                phone: elements.phone.value.trim(),
                notes: elements.notes.value.trim(),
                slots: groups.map(group => ({
                    date: group.date,
                    startTime: group.start,
                    endTime: group.end,
                    catalogItemId: state.activeRoomId || null // Pass selected room ID
                })),
                peopleCount: resolvePeopleCountInput() ?? 1
            };

            if (!payload.customerName || !payload.email || !payload.phone) {
                elements.errorMessage.textContent = 'è«‹å¡«å¯«å®Œæ•´è¯çµ¡è³‡æ–™ã€‚';
                elements.errorMessage.style.display = 'block';
                return;
            }

            try {
                elements.submitButton.disabled = true;
                elements.submitButton.textContent = 'æäº¤ä¸­...';
                const response = await fetch(`${API_BASE_URL}/bookings`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                const result = await response.json().catch(() => ({}));

                if (response.ok) {
                    saveUserDetails(); // Remember user
                    elements.successMessage.textContent = result.message || 'é ç´„å·²æäº¤ï¼Œè«‹ç•™æ„ç¢ºèªé€šçŸ¥ã€‚';
                    elements.successMessage.style.display = 'block';
                    openPaymentReminderModal(result.bookingId);
                    const affectedDates = Array.from(new Set(groups.map(group => group.date)));
                    state.selectedSlotsByDate.clear();
                    affectedDates.forEach(date => state.availabilityByDate.delete(date));
                    renderSummary();
                    calculateTotals();
                    elements.notes.value = ''; // clear notes
                    if (state.selectedDate) {
                        fetchAvailability(state.selectedDate);
                    }
                } else {
                    console.error('Booking create failed:', response.status, result);
                    const message = result?.error || 'ç„¡æ³•æäº¤é ç´„';
                    throw new Error(message);
                }
            } catch (error) {
                console.error(error);
                elements.errorMessage.textContent = error.message || 'æäº¤å¤±æ•—ï¼Œè«‹ç¨å¾Œå†è©¦ã€‚';
                elements.errorMessage.style.display = 'block';
            } finally {
                elements.submitButton.disabled = false;
                elements.submitButton.textContent = 'æäº¤é ç´„ç”³è«‹';
                updateSubmitButtonState();
            }
        });

        // Initialize
        (async function init() {
            setTodayAsMinDate();
            loadUserDetails(); // Load saved user info

            // Parallel fetch
            const [settings, rentalItems] = await Promise.all([
                loadSettings(),
                fetchRentalItems()
            ]);

            if (rentalItems && rentalItems.length > 0) {
                populateRoomSelect(rentalItems);
            }
            // loadSettings already applies rules/state.settings internally if checks passed?
            // Actually loadSettings implementation (visible in file?) assigns to state.settings

            // Set default date to today
            const today = new Date();
            const dateStr = formatDateInputValue(today);
            elements.dateInput.value = dateStr;
            handleDateChange({ target: { value: dateStr } });
        })();

        // Remove any legacy footer note that might persist from cached assets
        document.querySelectorAll('footer').forEach((footer) => {
            const text = footer.textContent.trim();
            if (
                text.includes('ç‡Ÿæ¥­æ™‚é–“ç”±å¾Œå°è¨­å®šè‡ªå‹•å¥—ç”¨') ||
                text.includes('èª²å ‚è³‡æ–™èˆ‡æ–¹æ¡ˆçš†ç”±å¾Œå°è¨­å®š') ||
                text.includes('Powered by the Studio Booking backend API')
            ) {
                footer.remove();
            }
        });
    </script>
</body>

</html>